<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Client-only Upload & Download (IndexedDB)</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; max-width:900px; margin:1rem auto; padding:1rem; }
    header { display:flex; gap:1rem; align-items:center; }
    button { cursor: pointer; }
    ul { list-style:none; padding-left:0; }
    li { margin-bottom:.5rem; display:flex; gap:1rem; align-items:center; }
    .meta { color:#666; font-size:.9rem; }
    .controls { margin-left:auto; display:flex; gap:.5rem; }
    .notice { background:#fffae6; border:1px solid #ffe58f; padding:.5rem; margin-bottom:1rem; }
  </style>
</head>
<body>
  <header>
    <h1>Client-only Upload & Download</h1>
  </header>

  <p class="notice">Files are stored locally in your browser (IndexedDB). No server or installation required. Files are only available on this device and browser profile.</p>

  <section>
    <form id="uploadForm">
      <input type="file" id="fileInput" required />
      <button type="submit">Store file locally</button>
    </form>
    <div id="status" aria-live="polite"></div>
  </section>

  <section>
    <h2>Stored files</h2>
    <ul id="fileList"></ul>
    <p id="emptyMsg">No files stored yet.</p>
  </section>

  <script>
    // Minimal IndexedDB helper
    const DB_NAME = 'local-files-db-v1';
    const STORE_NAME = 'files';

    function openDb() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function addFile(entry) {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.add(entry);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || 'add failed');
      });
    }

    async function getAllFiles() {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const req = store.getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function deleteFile(id) {
      const db = await openDb();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).delete(id);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    function formatBytes(n) {
      if (n < 1024) return n + ' B';
      if (n < 1024*1024) return Math.round(n/1024) + ' KB';
      return (n / (1024*1024)).toFixed(2) + ' MB';
    }

    async function refreshList() {
      const list = document.getElementById('fileList');
      const empty = document.getElementById('emptyMsg');
      list.innerHTML = '';
      try {
        const files = await getAllFiles();
        if (!files.length) {
          empty.style.display = '';
          return;
        }
        empty.style.display = 'none';
        files.reverse().forEach(f => {
          const li = document.createElement('li');
          const name = document.createElement('span');
          name.textContent = f.name + ' (' + formatBytes(f.size) + ')';
          const meta = document.createElement('span');
          meta.className = 'meta';
          meta.textContent = ' uploaded ' + new Date(f.uploadedAt).toLocaleString();

          const controls = document.createElement('div');
          controls.className = 'controls';

          const dl = document.createElement('a');
          dl.href = URL.createObjectURL(f.blob);
          dl.download = f.name;
          dl.textContent = 'Download';
          dl.addEventListener('click', () => setTimeout(() => URL.revokeObjectURL(dl.href), 1000));

          const del = document.createElement('button');
          del.textContent = 'Delete';
          del.addEventListener('click', async () => {
            if (!confirm('Delete "' + f.name + '"?')) return;
            await deleteFile(f.id);
            await refreshList();
          });

          controls.appendChild(dl);
          controls.appendChild(del);

          li.appendChild(name);
          li.appendChild(meta);
          li.appendChild(controls);
          list.appendChild(li);
        });
      } catch (err) {
        console.error(err);
        document.getElementById('status').textContent = 'Failed to read stored files.';
      }
    }

    document.getElementById('uploadForm').addEventListener('submit', async (ev) => {
      ev.preventDefault();
      const input = document.getElementById('fileInput');
      const status = document.getElementById('status');
      if (!input.files || !input.files.length) return;
      const file = input.files[0];
      status.textContent = 'Storing...';
      try {
        // Read file as Blob (we can store the Blob directly)
        const blob = file.slice(0, file.size);
        const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString() + '-' + Math.random().toString(36).slice(2));
        const entry = {
          id,
          name: file.name,
          type: file.type,
          size: file.size,
          uploadedAt: new Date().toISOString(),
          blob
        };
        await addFile(entry);
        status.textContent = 'Stored "' + file.name + '".';
        input.value = '';
        await refreshList();
      } catch (err) {
        console.error(err);
        status.textContent = 'Failed to store file.';
      }
    });

    // initial load
    refreshList();
  </script>
</body>
</html>
